#!/bin/bash
if [ -z "${MODEL_PATH:-}" ]; then
    echo "Error: MODEL_PATH environment variable is not set" >&2
    exit 1
fi
set -euo pipefail
IFS=$'\n\t'

# If the input is a URL, download the audio using yt-dlp.
if [[ "$1" =~ ^https?:// ]]; then
    echo "Downloading audio from URL: $1" >&2
    yt-dlp -f bestaudio --output "downloaded.%(ext)s" "$1"
    INPUT_FILE=$(ls downloaded.* 2>/dev/null | head -n 1)
    if [[ -z "$INPUT_FILE" ]]; then
        echo "Error: yt-dlp download failed" >&2
        exit 1
    fi
    echo "Downloaded file: $INPUT_FILE" >&2
    set -- "$INPUT_FILE"
fi

# Dummy cache_file implementation.
cache_file() {
    local FILE="$1"
    local SUFFIX="$2"
    local CACHE="${FILE}${SUFFIX}"
    # If the cache file doesn't exist, create it as a copy.
    if [[ ! -f "$CACHE" ]]; then
        cp "$FILE" "$CACHE" 2>/dev/null || :
    fi
    echo "$CACHE"
}

# Run whisper-cli only once per audio file.
run_whisper() {
    local WAV_FILE="$1"
    local BASE_NAME="${WAV_FILE%.*}"
    local OUT_FILE="${BASE_NAME}.out"
    local CACHE_TRANSCRIPT
    CACHE_TRANSCRIPT=$(cache_file "$OUT_FILE" ".cached")
    
    if [[ -s "$CACHE_TRANSCRIPT" ]]; then
        echo "Reusing cached transcript: $CACHE_TRANSCRIPT" >&2
        echo "$CACHE_TRANSCRIPT"
        return 0
    fi

    echo "Running Whisper-CPP for $WAV_FILE..." >&2
    if ! whisper-cli -tdrz -m "${MODEL_PATH:?Error: MODEL_PATH environment variable not set}" "$WAV_FILE" > "$OUT_FILE"; then
        echo "Error: Whisper-CPP transcription failed." >&2
        rm -f "$OUT_FILE"
        exit 1
    fi

    cache_file "$OUT_FILE" ".cached"
    echo "$OUT_FILE"
}

# Main execution.
if [[ $# -lt 1 || ! -f "$1" ]]; then
    echo "Error: Input file not provided or doesn't exist"
    exit 1
fi

INPUT_FILE="$1"
EXT="${INPUT_FILE##*.}"
WAV_FILE="${INPUT_FILE%.*}.wav"

# If input is a textual transcript (vtt or out), perform cleaning only.
if [[ "$EXT" == "vtt" || "$EXT" == "out" ]]; then
    echo "Performing cleaning on textual input file: $INPUT_FILE" >&2
    if [[ "$EXT" == "vtt" ]]; then
         python vttclean.py "$INPUT_FILE"
    else
         python clean-transcript.py "$INPUT_FILE"
    fi
    exit 0
fi

# Convert to WAV if needed.
if [[ "$EXT" != "wav" ]]; then
    if ! ffmpeg -i "$INPUT_FILE" -ar 16k -c:a pcm_s16le -y "$WAV_FILE"; then
        echo "Error: ffmpeg conversion failed" >&2
        exit 1
    fi
fi

TRANSCRIPT=$(run_whisper "$WAV_FILE")
echo "Transcript available at: $TRANSCRIPT"

# Immediately schedule the next job.
if ! add_job "process_vtt" "${WAV_FILE%.wav}.vtt" "$INPUT_FILE"; then
    echo "Error: Adding job failed" >&2
fi

# (Additional code for converting to OGG Opus and cleanup would follow here.)
