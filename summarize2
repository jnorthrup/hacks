#!/bin/bash
# Minimal transcription script using whisper-cli with diarization and transcript cleaning.


set -euo pipefail
IFS=$'\n\t'

# Set the path to the Whisper model
MODEL_PATH="/Users/jim/work/whisper.cpp/models/ggml-small.en-tdrz.bin"

# Check dependencies
for cmd in yt-dlp ffmpeg whisper-cli python; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "Error: $cmd is not installed." >&2
        exit 1
    fi
done

# Usage: $0 <input_file_or_url>
if [[ $# -lt 1 ]]; then
    echo "Usage: $0 <input_file_or_url>" >&2
    exit 1
fi

INPUT="$1"

# Use an environment variable for duration
: "${DURATION:=}"
FFMPEG_DURATION_ARG=""
if [[ -n "$DURATION" ]]; then
    FFMPEG_DURATION_ARG="-t $DURATION"
fi

# If input is a URL, download audio
if [[ "$INPUT" =~ ^https?:// ]]; then
    echo "Downloading audio from URL..."
    yt-dlp -f bestaudio --output "downloaded.%(ext)s" "$INPUT"
    INPUT=$(ls downloaded.* | head -n 1)
    if [[ -z "$INPUT" ]]; then
        echo "Error: Audio download failed." >&2
        exit 1
    fi
fi

# Determine input file type based on extension
EXT="${INPUT##*.}"
if [[ "$EXT" == "vtt" || "$EXT" == "out" ]]; then
    TRANSCRIPT_FILE="${INPUT%.*}_cleaned.txt"
    echo "Input file is VTT or .out; skipping conversion and transcription."
    echo "Cleaning transcript..."
    # Use process substitution to handle filename escapes
    python clean-transcript.py "$INPUT" "$TRANSCRIPT_FILE"
    echo "Transcript available at: $TRANSCRIPT_FILE"
    exit 0
elif [[ "$EXT" != "wav" ]]; then
    WAV_FILE="${INPUT%.*}.wav"
    echo "Converting $INPUT to WAV..."
    ffmpeg -y -i "$INPUT" $FFMPEG_DURATION_ARG -ar 16000 -c:a pcm_s16le "$WAV_FILE"
else
    WAV_FILE="$INPUT"
fi

# Run Whisper transcription with diarization
TRANSCRIPT_FILE="${WAV_FILE%.*}.txt"
echo "Running Whisper transcription..."
whisper-cli -tdrz -m "$MODEL_PATH" "$WAV_FILE" > "$TRANSCRIPT_FILE"

# Clean the transcript
echo "Cleaning transcript..."
python clean-transcript.py "$TRANSCRIPT_FILE"

echo "Transcript available at: $TRANSCRIPT_FILE"

# Cleanup temporary WAV file if conversion was done
if [[ "$EXT" != "wav" ]]; then
    echo "Cleaning up temporary file: $WAV_FILE" >&2
    rm -f "$WAV_FILE"
fi
