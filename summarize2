#!/bin/bash

# Configuration (adjust these paths)
MODEL_PATH="$HOME/.cache/whisper.cpp/ggml-small.en-tdrz.bin"
OUTPUT_DIR="$HOME/processed_audio"
CACHE_DIR="/tmp/summarize_cache"
WHISPCC="$HOME/.local/bin/whisper.cpp"
OLLAMA_MODEL="mistral:latest"
OLLAMA_MODEL="llama3.1:latest"

# Global variable to track job queue
JOB_QUEUE=()

# Ensure output and cache directories exist
mkdir -p "$OUTPUT_DIR" "$CACHE_DIR"

# Parse command line options
USE_FABRIC=false
while getopts "f" opt; do
  case $opt in
    f)
      USE_FABRIC=true
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
  esac
done
shift $((OPTIND-1))

# Function to get MD5 hash of a file
get_md5() {
    md5sum "$1" | awk '{ print $1 }'
}

# Function to cache a file using hardlinks (atomic)
cache_file() {
    local INPUT_FILE="$1"
    local EXTENSION="$2"
    local MD5=$(get_md5 "$INPUT_FILE")
    local CACHE_SUBDIR="$CACHE_DIR/${MD5:0:2}/${MD5:2:2}"
    local CACHE_FILE="$CACHE_SUBDIR/$MD5$EXTENSION"

    mkdir -p "$CACHE_SUBDIR"
    ln -f "$INPUT_FILE" "$CACHE_FILE"
    echo "$CACHE_FILE"
}

# Function to clean text from a VTT file
clean_text() {
    sed 's/<[^>]*>//g' | tr -s ' ' | sed 's/^[ \t]*//;s/[ \t]*$//'
}

# Function to summarize a segment of text
summarize_segment() {
    local SEGMENT_TEXT="$1"
    local SUMMARY_OUTPUT=""

    if $USE_FABRIC; then
        SUMMARY_OUTPUT=$(fabric -p summarize <<< "$SEGMENT_TEXT" 2>&1)
    else
        # Use ollama for summarization
        prom=(This transcript needs to be given a topic sentence, followed by the salient points made by the conversation and followed up by a conclusion. You will use markdown layouts without a lot of special chars. Nuggets need a timestamp in the format '00:00:00 sentence' to link to the source media in our comment parser. Be fully candid with language shared. You are a workaholic addicted to perfect kmeans-like division of large captions equally spacing the contents being summarized or noting which parts to skip to. Your summary below: )
        SUMMARY_OUTPUT=$(ollama run "$OLLAMA_MODEL" "${prom[*]}" <<< "$SEGMENT_TEXT" 2>&1)
    fi

    if [ $? -ne 0 ]; then
        echo "Error in summarization: $SUMMARY_OUTPUT" >&2
        return 1
    fi

    echo "$SUMMARY_OUTPUT"
}

# Function to add a job to the queue
add_job() {
    JOB_QUEUE+=("$@")
}

# Function to update the progress bar for a job
update_job_progress() {
    local JOB_INDEX="$1"
    local TOTAL_STEPS="$2"
    local CURRENT_STEP="$3"
    local JOB_MESSAGE="$4"

    # ... (Implementation for updating the TUI progress bar)
    # You can use a library like 'whiptail' or 'dialog' for TUI elements
    # Example using echo for now:
    echo "Job $((JOB_INDEX+1))/$JOB_COUNT: $JOB_MESSAGE ($CURRENT_STEP/$TOTAL_STEPS)"
}

# Function to process the job queue
process_job_queue() {
    local JOB_COUNT=${#JOB_QUEUE[@]}
    echo "Processing job queue ($JOB_COUNT jobs)..."
    for (( i=0; i<JOB_COUNT; i++ )); do
        # Example job execution with progress updates
        echo "Processing job $((i+1))/$JOB_COUNT: ${JOB_QUEUE[$i]}"
        update_job_progress "$i" 10 1 "Starting job..."
        # ... (Job execution logic)
        update_job_progress "$i" 10 5 "Processing..."
        # ... (More job execution logic)
        update_job_progress "$i" 10 10 "Finishing job..."
        # Execute the job 
        # eval "${JOB_QUEUE[$i]}"
        process_vtt "${JOB_QUEUE[$i]}"
    done
}

# Function to process a VTT file (generate summary and handle versioning)
process_vtt() {
    local VTT_FILE="$1"
    local BASE_NAME="${VTT_FILE%.vtt}"
    local CACHED_VTT=$(cache_file "$VTT_FILE" ".vtt")
    
    # Tiling for large transcripts
    MAX_WORDS_PER_TILE=500

    # Clean the VTT transcript
    local CLEANED_TRANSCRIPT="${CACHED_VTT%.vtt}_cleaned.txt"
    python3 vttclean.py "$CACHED_VTT" > "$CLEANED_TRANSCRIPT" 2>"${CLEANED_TRANSCRIPT}.error"
    if [ $? -ne 0 ]; then
        echo "Error: Failed to clean the VTT file. Error log:" >&2
        cat "${CLEANED_TRANSCRIPT}.error" >&2
        exit 1
    fi

    # Calculate and print the workplan (number of segments)
    TOTAL_WORDS=$(wc -w "$CLEANED_TRANSCRIPT" | awk '{print $1}')
    NUM_SEGMENTS=$(( (TOTAL_WORDS + MAX_WORDS_PER_TILE - 1) / MAX_WORDS_PER_TILE ))
    echo "Workplan: Summarizing $TOTAL_WORDS words in $NUM_SEGMENTS segments..." >&2

    # Generate summary (always fresh)
    SUMMARY_FILE="${BASE_NAME}_summary.txt"
    echo "Summarizing transcript..."

    # Tiling for large transcripts
    current_words=0
    segment_text=""
    segment_count=0
    > "$SUMMARY_FILE"  # Clear the summary file

    while IFS= read -r line || [ -n "$line" ]; do
        words_in_line=$(echo "$line" | wc -w)
        current_words=$((current_words + words_in_line))

        if [ "$current_words" -le "$MAX_WORDS_PER_TILE" ]; then
            segment_text="${segment_text}${line}\n"
        else
            # Process the current segment
            segment_count=$((segment_count + 1))
            echo "Processing segment $segment_count..." >&2
            summary=$(summarize_segment "$segment_text")
            if [ $? -ne 0 ]; then
                echo "Error: Failed to summarize segment $segment_count." >&2
                echo "Problematic segment text:" >&2
                echo "$segment_text" >&2
                exit 1
            fi
            echo "$summary" >> "$SUMMARY_FILE"

            # Reset for the next segment
            segment_text="${line}\n"
            current_words=$words_in_line
        fi
    done < "$CLEANED_TRANSCRIPT"

    # Summarize the last segment
    if [ -n "$segment_text" ]; then
        segment_count=$((segment_count + 1))
        echo "Processing final segment $segment_count..." >&2
        summary=$(summarize_segment "$segment_text")
        if [ $? -ne 0 ]; then
            echo "Error: Failed to summarize final segment $segment_count." >&2
            exit 1
        fi
        echo "$summary" >> "$SUMMARY_FILE"
    fi

    echo "Summarization complete. Processed $segment_count segments." >&2

    # Versioned summary output
    local VERSION=1
    while [ -f "${BASE_NAME}_summary_v${VERSION}.txt" ]; do
        VERSION=$((VERSION+1))
    done
    cp "$SUMMARY_FILE" "${BASE_NAME}_summary_v${VERSION}.txt"

    # Copy transcript without versioning
    cp "$CLEANED_TRANSCRIPT" "${BASE_NAME}.txt"

    echo "Processing complete!"
    echo "Files available:"
    echo " - Transcript: ${BASE_NAME}.txt"
    echo " - Summary: ${BASE_NAME}_summary_v${VERSION}.txt"
    cat "$SUMMARY_FILE"
}

# Add any processing tasks to the job queue
add_job "$1"

# Main script logic
if [[ "$1" == *.vtt ]]; then
    echo "Processing as VTT file..."
    # process_vtt "$1"
elif [[ "$1" == *"http"* ]]; then
    echo "Processing as YouTube URL..."

    # Attempt to download subtitles first
    yt-dlp --skip-download --write-auto-sub --sub-lang en \
           --cookies-from-browser brave --output "$OUTPUT_DIR/%(title)s.%(ext)s" "$1"

    VTT_FILE=$(find "$OUTPUT_DIR" -name "*.vtt" | head -n 1)

    if [ -n "$VTT_FILE" ]; then
        echo "Subtitles found, processing VTT file..."
        # process_vtt "$VTT_FILE"
    else
        echo "No subtitles found, downloading audio and generating transcript..."
        yt-dlp -x --audio-format wav --postprocessor-args "-ar 16k" \
               --cookies-from-browser brave --output "$OUTPUT_DIR/%(title)s.%(ext)s" "$1"

        WAV_FILE=$(find "$OUTPUT_DIR" -name "*.wav" | head -n 1)

        if [ -z "$WAV_FILE" ]; then
            echo "Error: Failed to download audio."
            exit 1
        fi

        echo "Running Whisper-CPP to generate VTT transcript..."
        "$WHISPCC" -ovtt -tdrz -m "$MODEL_PATH" "$WAV_FILE"
        VTT_FILE="${WAV_FILE%.wav}.vtt"

        # process_vtt "$VTT_FILE"

        # Convert WAV to OGG Opus
        echo "Converting WAV to OGG Opus..."
        OGG_FILE="${WAV_FILE%.wav}.ogg"
        ffmpeg -i "$WAV_FILE" -c:a libopus -b:a 56k -ar 16k "$OGG_FILE"
        echo " - Audio: $OGG_FILE"
    fi
elif [ -f "$1" ]; then
    echo "Processing as local audio file..."
    WAV_FILE="$1"

    echo "Running Whisper-CPP to generate VTT transcript..."
    "$WHISPCC" -ovtt -tdrz -m "$MODEL_PATH" "$WAV_FILE"
    VTT_FILE="${WAV_FILE%.wav}.vtt"

    # process_vtt "$VTT_FILE"
else
    echo "Error: Invalid input. Provide a valid URL, VTT file, or a local audio file."
    exit 1
fi
process_job_queue
